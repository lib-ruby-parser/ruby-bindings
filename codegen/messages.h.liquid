#ifndef MESSAGES_H
#define MESSAGES_H

// This file is autogenerated by {{ template }}

#include <stdint.h>
#include <ruby.h>
#include "c-bindings/lib-ruby-parser.h"

static VALUE LIB_RUBY_PARSER_String__to_ruby(LIB_RUBY_PARSER_String *string);
static VALUE uint8_t__to_ruby(uint8_t *n);

{% for message in messages %}
static VALUE LIB_RUBY_PARSER_{{ message.camelcase_name }}__to_ruby(LIB_RUBY_PARSER_{{ message.camelcase_name }} *variant)
{
    VALUE rb_mLibRubyParser = rb_const_get(rb_cObject, rb_intern("LibRubyParser"));
    VALUE rb_mMessages = rb_const_get(rb_mLibRubyParser, rb_intern("Messages"));
    VALUE rb_c{{ message.camelcase_name }} = rb_const_get(rb_mMessages, rb_intern("{{ message.camelcase_name }}"));
    VALUE rb_result = rb_obj_alloc(rb_c{{ message.camelcase_name }});
    {%- for field in message.fields %}
    {%- case field.field_type -%}
    {%- when "Str" -%}
        {%- assign field_type = "LIB_RUBY_PARSER_String" -%}
    {%- when "Byte" -%}
        {%- assign field_type = "uint8_t" -%}
    {%- else -%}
        {%- assign field_type = "COMPILE ERROR" -%}
    {%- endcase %}
    rb_ivar_set(rb_result, rb_intern("@{{ field.snakecase_name }}"), {{ field_type }}__to_ruby(&(variant->{{ field.snakecase_name | escape_c_keyword }})));
    {%- endfor %}
    return rb_result;
}
{% endfor %}

static VALUE LIB_RUBY_PARSER_DiagnosticMessage__to_ruby(LIB_RUBY_PARSER_DiagnosticMessage *message)
{
    switch(message->tag)
    {
{%- for message in messages %}
        case LIB_RUBY_PARSER_MESSAGE_{{ message.camelcase_name | camelcase_to_snakecase | upcase }}:
            return LIB_RUBY_PARSER_{{ message.camelcase_name }}__to_ruby(&(message->as.{{ message.camelcase_name | camelcase_to_snakecase | escape_c_keyword }}));
{%- endfor %}
        default:
            return Qnil;
    }
}

#endif // MESSAGES_H
