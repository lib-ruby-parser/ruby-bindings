use lib_ruby_parser_nodes::template::*;

const TEMPLATE: &str = "#ifndef MESSAGES_H
#define MESSAGES_H

// This file is autogenerated by {{ helper generated-by }}

#include <stdint.h>
#include <ruby.h>
#include \"c-bindings/lib-ruby-parser.h\"

static VALUE LIB_RUBY_PARSER_String__to_ruby(LIB_RUBY_PARSER_String *string);
static VALUE uint8_t__to_ruby(uint8_t *n);

{{ each message }}<dnl>
static VALUE LIB_RUBY_PARSER_{{ helper message-camelcase-name }}__to_ruby(LIB_RUBY_PARSER_{{ helper message-camelcase-name }} *variant)
{
    VALUE rb_mLibRubyParser = rb_const_get(rb_cObject, rb_intern(\"LibRubyParser\"));
    VALUE rb_mMessages = rb_const_get(rb_mLibRubyParser, rb_intern(\"Messages\"));
    VALUE rb_c{{ helper message-camelcase-name }} = rb_const_get(rb_mMessages, rb_intern(\"{{ helper message-camelcase-name }}\"));
    VALUE rb_result = rb_obj_alloc(rb_c{{ helper message-camelcase-name }});
{{ each message-field }}<dnl>
    rb_ivar_set(rb_result, rb_intern(\"{{ helper message-field-name }}\"), {{ helper message-field-c-field-type }}__to_ruby(&(variant->{{ helper message-field-c-name }})));
{{ end }}<dnl>
    return rb_result;
}
{{ end }}<dnl>

static VALUE LIB_RUBY_PARSER_DiagnosticMessage__to_ruby(LIB_RUBY_PARSER_DiagnosticMessage *message)
{
    switch(message->tag)
    {
{{ each message }}<dnl>
        case LIB_RUBY_PARSER_MESSAGE_{{ helper message-upper-name }}:
            return LIB_RUBY_PARSER_{{ helper message-camelcase-name }}__to_ruby(&(message->as.{{ helper message-lower-name }}));
{{ end }}<dnl>
        default:
            return Qnil;
    }
}

#endif // MESSAGES_H
";

pub(crate) fn codegen() {
    let template = TemplateRoot::new(TEMPLATE).unwrap();
    let fns = crate::codegen::fns::default_fns!();

    let contents = template.render(ALL_DATA, &fns);
    std::fs::write("../messages.h", contents).unwrap();
}
